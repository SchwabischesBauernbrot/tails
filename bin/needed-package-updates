#!/usr/bin/env python3
"""
Generate a list of packages that should be updated from Debian.
It use the API of https://qa.debian.org/cgi-bin/madison.cgi to get a
list of version in the Debian repository.

By default it will get the last successful build manifest file from testing or stable from here:
https://nightly.tails.boum.org/build_Tails_ISO_testing/lastSuccessful/archive/build-artifacts/
https://nightly.tails.boum.org/build_Tails_ISO_stable/lastSuccessful/archive/build-artifacts/
"""

import argparse
from dataclasses import dataclass
import itertools
import logging
import operator
import re
import sys
import urllib

import requests
import yaml

import apt
import distro_info
from debian.debian_support import Version

apt_cache = apt.Cache()

logger = logging.getLogger()

MADISON = None
SUITES = None

def batched(iterable, max_length):
    "Batch data into tuples of length n. The last batch may be shorter."
    # see https://docs.python.org/3/library/itertools.html#itertools-recipes
    # batched('ABCDEFG', 3) --> ABC DEF G
    if max_length < 1:
        raise ValueError('n must be at least one')
    iterator = iter(iterable)
    while batch := tuple(itertools.islice(iterator, max_length)):
        yield batch


def partition(pred, iterable):
    "Use a predicate to partition entries into false entries and true entries"
    # partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9

    match = []
    non_match = []

    for i in iterable:
        if pred(i)():
            match.append(i)
        else:
            non_match.append(i)

    return non_match, match


class NoBuildManifest(Exception):
    pass


def add_metadata(yml, name):
    yml['file_name'] = name
    match = re.match(r".*@([0-9a-f]+)-([0-9T]+Z).build-manifest", name)
    if match:
        yml['git_hash'] = match.group(1)
        yml['timestamp'] = match.group(2)


def get_build_manifest(suite: str) -> dict:
    base_url = f"https://nightly.tails.boum.org/build_Tails_ISO_{suite}/lastSuccessful/archive/build-artifacts/"

    shasum_response = requests.get(urllib.parse.urljoin(base_url, "tails-build-artifacts.shasum"))

    try:
        shasum_response.raise_for_status()
    except requests.HTTPError as e:
        raise NoBuildManifest(f"build-manifest file for {suite} not found!") from e

    for i in shasum_response.text.splitlines():
        _, name = i.split()

        if name.endswith(".build-manifest"):
            url = urllib.parse.urljoin(base_url, name)
            bm_response = requests.get(url, timeout=60)
            ret = yaml.safe_load(bm_response.text)  # type: dict
            ret['url'] = url
            add_metadata(ret, name)
            return ret

    raise NoBuildManifest(f"build-manifest file for {suite} not found!")


class NotFoundError(Exception):
    pass


class Madison:
    """ to manage output of https://qa.debian.org/cgi-bin/madison.cgi.
    Normally you give a list of packages you want to check and get the versions on different suites."""
    def __init__(self, packages):
        self.packages = self._request(packages)

    def _request(self, packages: list[str]) -> dict:
        ret = {}
        for pkgs in batched(packages, 100):
            r = requests.get("https://qa.debian.org/cgi-bin/madison.cgi",
                             {
                                 "package":" ".join(pkgs),
                                 "yaml":"on",
                             },
                             timeout=60)
            ret |= yaml.safe_load(r.text)
        return ret

    def version(self, name: str, suite: str) -> Version:
        v = None
        package = self.packages[name]
        channels = {suite, suite+"/contrib", suite+"/non-free", suite+"/non-free-firmware"}
        for version, suite_info in package.items():
            for s in set(suite_info.keys()) & channels:
                if "source" not in suite_info[s]:
                    continue
                if not v or v < Version(version):
                    v = Version(version)
        if v is None:
            raise NotFoundError(f"{name} not found in {suite}")

        return v

    def get_debian_version(self, name: str, version: Version) -> tuple:
        for suite in SUITES:
            try:
                suite_version = self.version(name, suite)
            except NotFoundError:
                continue
            if version <= suite_version:
                return (suite, suite_version)
        else:
            raise Exception(f"{name}: the package version({version}) is higher than the version on {suite} ({suite_version})")


def strip_tails_version(version: str) -> Version:
    """ if we have a Tails own fork get the Debian version."""
    match = re.match(r"^(.*)(\.0tails[0-9]+)$", version)
    if match:
        return Version(match[1])
    else:
       return Version(version)


def get_source_pkgs(build_manifest: dict) -> dict:
    """ binary package names to source package names."""
    ret = {}

    for pkg in build_manifest['packages']['binary']:
        try:
            a_pkg = apt_cache[pkg['package']]
        except KeyError:
            # The better approch instead of explit binary -> source names
            # would be to add the apt snapshot to apt source /etc/apt/sources.list.d/
            if re.fullmatch(r'linux-image-.*-amd64', pkg['package']):
                ret["linux-signed-amd64"] = Version(pkg['version'])
                continue
            raise
        try:
            version = a_pkg.versions[pkg['version']]
        except KeyError as e:
            for v in a_pkg.versions:
                ret[v.source_name] = Version(pkg['version'])
        else:
            ret[version.source_name] = Version(version.source_version)
    return ret


@dataclass
class NewVersionIssue:
    name: str
    version: Version
    suite: str
    suite_version: Version

    def __str__(self):
        return f"{self.name} ({self.version}) to Debian {self.suite} ({self.suite_version})"

    def tails_fork(self):
        return re.search('.0tails[0-9]+$', str(self.version)) is not None


def get_issues(package_dict: dict[str, Version]) -> list[NewVersionIssue]:
    """Get a issue list of updateable packages."""
    ret = []
    global MADISON
    MADISON = Madison(package_dict.keys())
    for package, version in package_dict.items():
        striped_version = strip_tails_version(str(version))
        suite, suite_version = MADISON.get_debian_version(package, striped_version)

        if striped_version < suite_version:
            ret.append(NewVersionIssue(package, version, suite, suite_version))
    return ret


def check_build_manifest(build_manifest: dict, config: dict, verbose: bool) -> dict:
    ignore = config.get('ignore', {})
    general_ignore = ignore.get('general', [])
    tmp_ignore = ignore.get('temporary', {})
    ret = True

    sources = get_source_pkgs(build_manifest)
    issues = get_issues(sources)

    def _is_ignored(issue):
        if issue.name in general_ignore:
            return True
        if str(issue.suite_version) == tmp_ignore.get(issue.name, {'version': None})['version']:
            return True
        return False

    if not verbose:
        issues = itertools.filterfalse(_is_ignored, issues)

    non_forked, forked = partition(operator.attrgetter('tails_fork'), sorted(issues, key=operator.attrgetter('name')))

    def _log_issue(issue):
        if _is_ignored(issue):
            if issue.name in general_ignore:
                return f"(always ignored) {issue}"
            return f"(known) {issue}"
        else:
            ret = True
            return str(issue)

    if forked:
        l = "\n  - ".join(map(_log_issue, forked))
        logger.info(f'Need to upgrade our own forked package:\n  - {l}')

    if non_forked:
        l = "\n  - ".join(map(_log_issue, non_forked))
        logger.info(f'Need to upgrade to a new APT snapshot:\n  - {l}')

    return ret


def get_suites(min_codename: str) -> list:
    suites = []
    ddi = distro_info.DebianDistroInfo()
    ddi_s = ddi.supported()
    codename_pos = ddi_s.index(min_codename)
    testing = ddi.testing()
    for suite in ddi_s[codename_pos:]:
        if suite in (testing, 'sid', 'experimental'):
            suites.append(suite)
        else:
            # We always want to make sure, that we have the stable-security version installed, if available.
            # The rest of the list follows the Debians package flow.
            suites.extend([f'{suite}-security', suite, f'{suite}-p-u', f'{suite}-backports'])

    return suites


def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(levelname)s: %(message)s',
    )
    logging.getLogger("urllib3.connectionpool").setLevel(logging.WARNING)

    parser = argparse.ArgumentParser(description='list all packages that ')
    parser.add_argument('-v', '--verbose', action='store_true', help='Give more infos')
    parser.add_argument('--debug', action='store_true', help='Show all debug messages')
    parser.add_argument('-c', '--config', type=argparse.FileType('r'), default="config/ci/needed-package-updates.yml", help='Config file')
    group = parser.add_mutually_exclusive_group()
    group.add_argument( '--suite', help='build manifest suite name.')
    group.add_argument( '--file', type=argparse.FileType('r'), help='local file name.')

    args = parser.parse_args()

    logger.setLevel(logging.DEBUG if args.debug else logging.INFO)

    if args.debug:
        args.verbose = True

    config = yaml.safe_load(args.config)

    global SUITES
    SUITES = tuple(get_suites(config.get('distribution')))

    if args.file:
        build_manifest = yaml.safe_load(args.file)
        add_metadata(build_manifest, args.file.name)
        logger.info("Check local file %s", build_manifest['file_name'])
    elif args.suite:
        build_manifest = get_build_manifest(args.suite)
        logger.info("Check %s", build_manifest['file_name'])
    else:
        err = None
        for suite in ("testing", "stable"):
            try:
                build_manifest = get_build_manifest(suite)
                logger.info("Check %s", build_manifest['file_name'])
                break
            except NoBuildManifest as e:
                logger.debug("No build manifest found for %s.", suite)
                err = e
        else:
            raise err

    propose_update = check_build_manifest(build_manifest, config, args.verbose)

    if propose_update:
        sys.exit(1)
    else:
        logger.debug("Nothing to do.")


if __name__ == "__main__":
    main()
