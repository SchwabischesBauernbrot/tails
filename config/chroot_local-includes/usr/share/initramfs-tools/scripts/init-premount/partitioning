#!/bin/sh

PREREQS="plymouth read-and-update-random-seed-sector"

prereqs() { echo "$PREREQS"; }

case "$1" in
	prereqs)
	prereqs
	exit 0
	;;
esac

set -eu

ESP_GUID="C12A7328-F81F-11D2-BA4B-00A0C93EC93B"

# We will run this after each action that alters the device/partition
# in any way in an attempt to avoid various races that has caused this
# script to fail at various points. Examples:
#  * `partprobe /dev/sda` exiting before /dev/sda1 exists, causing
#    errors in subsequent commands attempting to use /dev/sda1
#  * `mlabel` complaining that it "could not read boot sector"
settle() {
    sync
    udevadm settle
    sync
}

. /scripts/functions

set -x

if [ -z "${FSUUID:-}" ]; then
	echo "\$FSUUID is unset, probably because the boot medium is an ISO, and not a USB image. Skipping partitioning."
	exit 0
fi

# Wait for system partition
log_begin_msg "Waiting for system partition to become available"
i=0
while true; do
    if [ -b "/dev/disk/by-uuid/${FSUUID}" ]; then
        SYSTEM_PARTITION="$(readlink -f "/dev/disk/by-uuid/${FSUUID}")"
        PARENT_PATH="$(udevadm info --query=property --name="${SYSTEM_PARTITION}" |
            sed -n '/^ID_PATH=/ s/^ID_PATH=// p')"
        PARENT_DEVICE="$(readlink -f "/dev/disk/by-path/${PARENT_PATH}")"
        if [ -b "${PARENT_DEVICE}" ]; then
            break
        fi
    fi

    if [ "$i" -ge 300 ]; then
        log_failure_msg "Reached timeout waiting for system partition." \
            "Skipping partitioning."
        exit 0
    fi

    sleep 0.2
    i="$((i + 1))"
done
log_end_msg

DEVICE_NAME="$(basename "${PARENT_DEVICE}")"

first_boot_repartition() {
	# Compute the new system partition size

	# in 512 bytes sectors
	DEVICE_SIZE=$(cat "/sys/block/${DEVICE_NAME}/size")

	DEVICE_SIZE_IN_GB=$(echo "scale=1; ${DEVICE_SIZE} / 2 / 1000 / 1000" | bc)
	DEVICE_SIZE_IN_MiB=$((DEVICE_SIZE / 2 / 1024))
	DEVICE_TOO_SMALL_ERROR_MESSAGE="Sorry, this USB stick is too small to run Tails (${DEVICE_SIZE_IN_GB} GB). Please use a USB stick of at least 8 GB. Press ENTER to shut down."

	if [ "${DEVICE_SIZE_IN_MiB}" -lt 7200 ]; then
		plymouth message --text="${DEVICE_TOO_SMALL_ERROR_MESSAGE}"
		plymouth watch-keystroke > /dev/null
		poweroff -f
	elif [ "${DEVICE_SIZE_IN_MiB}" -lt 14500 ]; then
		SYSTEM_PARTITION_SIZE=4096M
	else
		SYSTEM_PARTITION_SIZE=8192M
	fi


	# Update partition table. This includes the following operations:
	# * Move GPT backup header to the end of the device
	# * Set a random disk GUID and partition GUID
	# * Delete the old system partition
	# * Create a new system partition of size ${SYSTEM_PARTITION_SIZE}
	# * Set the partition label to "Tails"
	log_begin_msg "Updating partition table"
	sgdisk \
		--move-second-header \
		--randomize-guids \
		--delete=1 \
		--new=1:0:+"${SYSTEM_PARTITION_SIZE}" \
		--typecode="1:${ESP_GUID}" \
		--change-name=1:Tails \
		"${PARENT_DEVICE}"
	settle
	log_end_msg

  if grep -qw "test_gpt_repair" /proc/cmdline; then
    # Corrupt the MBR and GPT to test the repair mechanism
    SECTORS=$(blockdev --getsz "${PARENT_DEVICE}")

    corrupt_options=$(sed -n 's/.*test_gpt_repair=\([^ ]*\).*/\1/p' /proc/cmdline)
    if echo "${corrupt_options}" | grep -qw mbr; then
      # Corrupt the MBR partition table
      dd if=/dev/zero of="${PARENT_DEVICE}" bs=1 count=64 seek=446
    fi
    if echo "${corrupt_options}" | grep -qw gpt; then
      # Corrupt the GPT main header
      dd if=/dev/zero of="${PARENT_DEVICE}" bs=512 count=1 seek=1
    fi
    if echo "${corrupt_options}" | grep -qw gpt_table; then
      # Corrupt the GPT main partition table
      dd if=/dev/zero of="${PARENT_DEVICE}" bs=512 count=32 seek=2
    fi
    if echo "${corrupt_options}" | grep -qw gpt_backup; then
      # Corrupt the GPT backup header
      dd if=/dev/zero of="${PARENT_DEVICE}" bs=512 count=1 seek=$((SECTORS - 1))
    fi
    if echo "${corrupt_options}" | grep -qw gpt_backup_table; then
      # Corrupt the GPT backup partition table
      dd if=/dev/zero of="${PARENT_DEVICE}" bs=512 count=32 seek=$((SECTORS - 33))
    fi
  fi

  GPT_IS_VALID=
  for i in 1 2 3; do
    # Verify the GPT headers and partition tables. We've seen cases where
    # both the MBR and the GPT backup tables were corrupted, which caused
    # the Persistent Storage partition to fail to be created.
    verify_output=$(sgdisk --verify "${PARENT_DEVICE}" 2>&1 || true)
    # Print the output of sgdisk --verify for debugging purposes
    echo "${verify_output}"

    # Check if sgdisk --verify detected any corruption. This verifies the
    # following:
    # * The protective MBR
    # * The GPT header
    # * The GPT partition table
    # * The GPT backup header
    # * The GPT backup partition table
    if ! echo "${verify_output}" | grep -q 'corrupt\|ERROR'; then
      _log_msg "The GPT is valid"
      GPT_IS_VALID=1
      break
    fi

    _log_msg "The GPT is corrupt. Attempting to repair it."
    # Wipe the GPT. sgdisk will exit with exit code 2 because the GPT is
    # corrupt, so we ignore the exit code.
    # Note that we can't use sgdisk --zap-all because it would also wipe
    # the MBR, which would remove the hybrid MBR that we need to boot on
    # legacy BIOS systems.
    sgdisk --zap "${PARENT_DEVICE}" || true
    settle
    # Recreate the GPT and the system partition
    sgdisk --new=1:0:+"${SYSTEM_PARTITION_SIZE}" \
      --typecode=1:"${ESP_GUID}" \
      --change-name=1:Tails \
      --mbrtogpt \
      "${PARENT_DEVICE}"
    settle
  done

  if [ -z "${GPT_IS_VALID}" ]; then
    MSG="Resizing the system partition has failed. The hardware of your USB stick is probably failing. Please install Tails on a different USB stick. Press ENTER to shut down."
    plymouth message --text="${MSG}"
    plymouth watch-keystroke > /dev/null
		poweroff -f
  fi

	# Tell the kernel to reload the partition table
	partprobe "${PARENT_DEVICE}"
	settle

	# fatresize overwrites the VBR, so we have to back it up to be able to
	# restore the boot code later
	dd if="${SYSTEM_PARTITION}" of=/tmp/vbr bs=512 count=1
	settle

	# Grow the filesystem
	# Note that fatresize resets partition attributes
	# fatresize uses "Mi" for MiB, so we have to append an "i".
	# Also, due to bugs in fatresize (tails/tails#18699) we
	# are limited to grow the filesystem to just below the limit.
	FS_SIZE="$((${SYSTEM_PARTITION_SIZE%M} - 2))"Mi
	fatresize --size="${FS_SIZE}" "${SYSTEM_PARTITION}"
	settle

	# Restore boot code overwritten by fatresize
	dd if=/tmp/vbr of="${SYSTEM_PARTITION}" bs=1 skip=90 seek=90 count=414
	settle

	# Restore JMP instruction which jumps to the bootcode
	dd if=/tmp/vbr of="${SYSTEM_PARTITION}" bs=3 count=1
	settle

	# Set a random filesystem UUID (aka. FAT "Volume ID" / "serial number")
	MTOOLS_SKIP_CHECK=1 mlabel -i "${SYSTEM_PARTITION}" -n ::Tails
	settle

	# Recompute CHS values for the hybrid MBR (see #16389),
	# set the partition type again (something has reset it to "Basic data"),
	# and set the following attributes on the system partition
	# (we have to set them after running fatresize, because fatresize
	# resets them):
	#   0: system partition
	#   2: legacy BIOS bootable
	#   60: read-only
	#   62: hidden
	#   63: do not automount
	sgdisk \
		--attributes=1:set:0  \
		--attributes=1:set:2  \
		--attributes=1:set:60 \
		--attributes=1:set:62 \
		--attributes=1:set:63 \
		--typecode="1:${ESP_GUID}" \
		--recompute-chs \
		"${PARENT_DEVICE}"
	settle

	# Tell the kernel to reload the partition table
	partprobe "${PARENT_DEVICE}"
	settle
}

repair_system_partition() {
	set +e
	fsck.fat -a -w -V -v "${SYSTEM_PARTITION}"
	FSCK_EXIT_CODE=$?
	set -e
	case "${FSCK_EXIT_CODE}" in
		0)
			_log_msg "fsck has detected no recoverable errors"
			;;
		1)
			_log_msg "fsck has fixed errors, deleting fsck recovery files"
			MOUNTPOINT=$(mktemp -d)
			mount -t vfat "${SYSTEM_PARTITION}" "${MOUNTPOINT}"
			find "${MOUNTPOINT}" \
			     -maxdepth 1 -type f -iname 'FSCK*.REC' \
			     -exec rm '{}' \;
			umount "${MOUNTPOINT}"
			;;
		*)
			_log_msg "fsck usage error. Ignoring and booting anyway."
			;;
	esac
}

# This section is duplicated in config/chroot_local-includes/usr/local/lib/tails-shell-library/hardware.sh
# please keep them in sync!

# Check if this is first boot
GUID=$(sgdisk --print "${PARENT_DEVICE}" \
	| sed -n '/^Disk identifier (GUID)/ s/^Disk identifier (GUID): // p')

if [ "${GUID}" = "17B81DA0-8B1E-4269-9C39-FE5C7B9B58A3" ]; then
	_log_msg "This is the first boot, so repartitioning"
	PLYMOUTH_MSG="Preparing Tails for first use..."
	plymouth display-message --text="${PLYMOUTH_MSG}"
	first_boot_repartition
	# `plymouth hide-message` doesn't work (#20401)
	plymouth display-message --text=""
else
	_log_msg "This is not the first boot, so repairing filesystem"
	PLYMOUTH_MSG="Checking the Tails system partition for errors..."
	plymouth display-message --text="${PLYMOUTH_MSG}"
	repair_system_partition
	# `plymouth hide-message` doesn't work (#20401)
	plymouth display-message --text=""
fi
