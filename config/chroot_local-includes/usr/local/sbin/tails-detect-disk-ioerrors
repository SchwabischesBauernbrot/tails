#!/usr/bin/env python3

"""
Detect SquashFS and other I/O error and if detected create
/var/lib/live/tails.disk.ioerrors. That file will be used to show the
user an error.
"""

from typing import Optional

from tailslib.utils import get_boot_device

import pathlib

import systemd.daemon
import systemd.journal

# File that indicates SquashFS and other I/O errors
DISK_IOERRORS = pathlib.Path("/var/lib/live/tails.disk.ioerrors")


def boot_device_name():
    device_path = get_boot_device()
    return device_path.split("/")[-1]


class IOErrorPatterns:
    def __init__(self):
        self.patterns = ["SQUASHFS error:"]

        self._add_pattern_boot_device(boot_device_name())

    def _add_pattern_boot_device(self, device: str):
        print(f"use boot device {device}")
        self.patterns.extend(
                [
                    f"I/O error, dev {device}, sector",
                    f"critical target error, dev {device}, sector",
                ]
            )

    def match_message(self, msg: str) -> bool:
        """Do the msg match any of the patterns."""
        for start in self.patterns:
            if msg.startswith(start):
                return True
        return False


def process_entries(journal: systemd.journal.Reader, ioerror_patterns: IOErrorPatterns):
    """Process all journald messages and search for SquashFS and other I/O errors."""
    for e in journal:
        msg = e["MESSAGE"]
        matched = ioerror_patterns.match_message(msg)

        if matched:
            print(msg)  # Add detected logs to own log
            DISK_IOERRORS.touch(exist_ok=True)


def main():
    ioerror_patterns = IOErrorPatterns()

    flags = systemd.journal.SYSTEM_ONLY | systemd.journal.LOCAL_ONLY
    j = systemd.journal.Reader(flags)
    j.this_boot()
    j.this_machine()
    j.log_level(systemd.journal.LOG_ERR)
    j.add_match(SYSLOG_IDENTIFIER="kernel")

    # On start we haven't detected any error
    DISK_IOERRORS.unlink(missing_ok=True)

    systemd.daemon.notify("STATUS=Processing existing messages...\n")

    print("process first batch...")
    # Process all existing log entries since boot
    process_entries(j, ioerror_patterns)

    # Notify systemd that we're ready
    systemd.daemon.notify("READY=1")
    systemd.daemon.notify("STATUS=Waiting for new messages to process...\n")

    print("start loop")
    # Wait for new messages to be appended to journald
    while True:
        # journal.wait will trigger process_entries for every message including all
        # messages, that do not match our filters.
        state_change = j.wait()
        if state_change == systemd.journal.APPEND:
            process_entries(j, ioerror_patterns)


if __name__ == "__main__":
    main()
