#!/usr/bin/env python3

"""
  Detect SQUASHFS and other I/O error and if detected create
  /var/lib/live/tails.disk.ioerrors. That file will be used to show
  the user an error.

  Copyright (C) 2023 Tails developers <tails@boum.org>

  You can redistribute  it and/or modify it under the  terms of the GNU
  General Public License as published by the Free Software Foundation;
  either version 3 of the License, or (at your option) any later version.

  This program  is distributed in the  hope that it will  be useful, but
  WITHOUT   ANY  WARRANTY;   without  even   the  implied   warranty  of
  MERCHANTABILITY  or FITNESS  FOR A  PARTICULAR PURPOSE.   See  the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from typing import Optional

import os
import gi

gi.require_version("UDisks", "2.0")
from gi.repository import UDisks

import tps.device

import pathlib

import systemd.daemon
import systemd.journal

# File that indicates SQUASHFS and other I/O errors
DISK_IOERRORS = pathlib.Path("/var/lib/live/tails.disk.ioerrors")

udisks = UDisks.Client.new_sync()


def boot_device() -> Optional[str]:
    """get the boot device name"""
    dev_num = os.stat(tps.device.TAILS_MOUNTPOINT).st_dev
    block = udisks.get_block_for_dev(dev_num)
    device_path = block.props.device

    device_object = block.get_object()
    partition = device_object.get_partition()
    if not partition:
        return device_path.split("/")[-1]

    partition_object = udisks.get_object(partition.props.table)
    device_path = partition_object.get_block().props.device

    return device_path.split("/")[-1]


def tps_device() -> Optional[str]:
    """get the device name of the Persistent Storage."""
    device = tps.device.TPSPartition.find()
    if not device:
        return None
    device_path = device.device_path
    return device_path.split("/")[-1]


def tps_cleartext_device() -> Optional[str]:
    """get the cleartext device name of the Persistent Storage."""
    print("tps_cleartext_device...")
    device = tps.device.TPSPartition.find()
    print(f"tps-device={device}")
    if not device:
        return None
    device = device.try_get_cleartext_device()
    print(f"cleartext-device={device}")
    if not device:
        return None
    device_path = device.device_path
    return device_path.split("/")[-1]


class IOErrorPattern:
    def __init__(self):
        self.patterns = ["SQUASHFS error:"]
        self.update_patterns = ["EXT-fs", "I/O error", "critical target error"]
        self.update_patterns_finished = False

        # None: is not checked
        # False: checked, but the system will never have such a device
        #        (e.g. started from a DVD will not have a TPS device)
        # type(str): name of the device
        self.boot_device: Optional[str] = None
        self.tps_device: Optional[str] = None
        self.cleartext_device: Optional[str] = None

    def _add_pattern_boot_device(self, device: str):
        self.patterns.append(f"I/O error, dev {device}, sector")
        self.boot_device = device
        print(f"set boot device to {device}")

    def _add_pattern_tps_device(self, device: str):
        self.tps_device = device
        print(f"set tps device to {device}")

    def _add_pattern_cleartext_device(self, device: str):
        self.patterns.extend(
            [
                f"EXT4-fs ({device}): I/O error",
                f"EXT4-fs error (device {device})",
                f"critical target error, dev {device}, sector",
                f"Buffer I/O error on dev {device}, logical block",
                f"JBD2: I/O error when updating journal superblock for {device}",
            ]
        )
        self.cleartext_device = device
        print(f"set cleartext device to {device}")

    def _update_patterns(self):
        """Check and update the pattern list."""

        print("_update_pattern.")

        if not self.boot_device:
            self._add_pattern_boot_device(boot_device())

        if self.tps_device is None:
            try:
                tps.device.BootDevice.get_tails_boot_device()
            except tps.device.NoUdisksPartitionObjectError:
                # ISO has no tps device
                self.tps_device = False  # False: Do not check again
                self.update_patterns_finished = True
                print ("update_patterns_finished = True")
                return

            _device = tps_device()
            if _device:
                self._add_pattern_tps_device(_device)

        if self.tps_device and not self.cleartext_device:
            _device = tps_cleartext_device()
            if _device:
                self._add_pattern_cleartext_device(_device)
                self.update_patterns_finished = True
                print ("update_patterns_finished = True")

    def match_message(self, msg: str) -> bool:
        """Do the msg match any of the patterns."""
        for start in self.patterns:
            if msg.startswith(start):
                return True
        return False

    def update_patterns_if_match(self, msg: str) -> bool:
        """Check if the error msg triggers update_pattern."""
        if self.update_patterns_finished:
            return False

        for pattern in self.update_patterns:
            if pattern in msg:
                self._update_patterns()
                return True
        return False


def process_entries(journal: systemd.journal.Reader, ioerror_pattern: IOErrorPattern):
    """Process all journald messages and search for SQUASHFS and other I/O errors."""

    # journal.wait will trigger process_entries for every message including all
    # messages, that do not match our filters. ioerror_pattern.update_patterns is
    # expensive to call. In the end we check for an interessting message,
    # before triggering update_patterns.

    # call update_pattern only once per call.
    updated_patterns_try = False

    for e in journal:
        msg = e["MESSAGE"]
        matched = ioerror_pattern.match_message(msg)

        if not matched and not updated_patterns_try:
            if ioerror_pattern.update_patterns_if_match(msg):
                matched = ioerror_pattern.match_message(msg)
            updated_patterns_try = True

        if matched:
            print(msg)  # Add detected logs to own log
            DISK_IOERRORS.touch(exist_ok=True)


def main():
    ioerror_pattern = IOErrorPattern()

    flags = systemd.journal.SYSTEM_ONLY | systemd.journal.LOCAL_ONLY
    j = systemd.journal.Reader(flags)
    j.this_boot()
    j.this_machine()
    j.log_level(systemd.journal.LOG_ERR)
    j.add_match(SYSLOG_IDENTIFIER="kernel")

    # On start we havn't detected any error
    DISK_IOERRORS.unlink(missing_ok=True)

    systemd.daemon.notify("STATUS=Processing existing messages...\n")

    print("process first batch...")
    # Process all existing log entries since boot
    process_entries(j, ioerror_pattern)

    # Notify systemd that we're ready
    systemd.daemon.notify("READY=1")
    systemd.daemon.notify("STATUS=Waiting for new messages to process...\n")

    print("start loop")
    # Wait for new messages to be appended to journald
    while True:
        state_change = j.wait()
        if state_change == systemd.journal.APPEND:
            process_entries(j, ioerror_pattern)


if __name__ == "__main__":
    main()
