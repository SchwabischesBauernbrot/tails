[[!meta title="Persistent Storage"]]

[[!toc levels=4]]


# What are we trying to achieve

## Introduction

As a live system designed to not leave any trace of its use on a
computer, Tails doesn't store any user data and configuration by
default. To still be able to use Tails without re-configuring all
used apps after each boot, Tails supports storing some
explicitly selected configuration and data persistently on an encrypted
volume.

## Requirements
Allow users to easily set up an encrypted volume and configure which
data and configuration should be stored persistently on the encrypted
volume.

## Design

Technical overview:

* Encrypted (LUKS) volume on the Tails device
* Configuration file containing source paths and destination paths
* Files are either bind-mounted or linked via symlinks
* Hooks are executed on activation / deactivation 

Components:

* A privileged backend: A D-Bus activated systemd service which exposes 
  an API via the D-Bus system bus
* A GTK app which uses the API to allow the user to easily set up and
  configure the Persistent Storage
* A command-line tool and shell library to allow other components of
  Tails to easily use the API to configure the Persistent Storage

# XXX

* Setup and configuration is done via the `Persistent Storage` app
* 
* User can choose which data and configuration (features) to 
  store persistently from a pre-configured list 
* In addition, users can make arbitrary files persistent by editing
  a config file manually
  pre-configured list of  which files and directories 
* Files and directories which are made persistent are copied to the 
  Persistent Storage
* Files and directories are 


## Backend

The backend is implemented as a D-Bus activated systemd service using
the D-Bus system bus. It exposes two interfaces:
XXX: link to the relevant code instead of copy-pasting a code block

```
<interface name='org.boum.tails.PersistentStorage'>
    <method name='Quit'/>
    <method name='Create'>
        <arg name='passphrase' direction='in' type='s'/>
    </method>
    <method name='ChangePassphrase'>
        <arg name='passphrase' direction='in' type='s'/>
        <arg name='new_passphrase' direction='in' type='s'/>
    </method>
    <method name='Delete'/>
    <method name='Activate'/>
    <method name='Unlock'>
        <arg name='passphrase' direction='in' type='s'/>
    </method>
    <property name="State" type="s" access="read" />
    <property name="Error" type="s" access="read" />
    <property name="IsCreated" type="b" access="read"/>
    <property name="IsUnlocked" type="b" access="read"/>
    <property name="BootDeviceIsSupported" type="b" access="read"/>
    <property name="Device" type="s" access="read"/>
    <property name="Job" type="o" access="read"/>
</interface>
```

and

```
<interface name='org.boum.tails.PersistentStorage.Feature'>
    <method name='Activate'/>
    <method name='Deactivate'/>
    <property name="Id" type="s" access="read"/>
    <property name="IsActive" type="b" access="read"/>
    <property name="Job" type="o" access="read"/>
</interface>
```



XXX: this section used to be about the old implementation. linkfiles is the only bit we need to preserve about
it.

* add a "linkfiles" (inspired by [Joey Hess'
  dircombine](http://git.kitenet.net/?p=joey/home.git;a=blob;f=bin/dircombine))
  option to create symlinks from the root of a non-persistent
  directory (e.g. `$HOME`) to regular files stored in
  a persistent location (e.g. `.gitconfig`, `.vimrc`, etc.)

### Example

Example `persistence.conf` configuration file:

	# destination       options
	/var/cache/apt
	/home/amnesia       linkfiles,source=dotfiles

This will result in:

* `$MEDIA/apt` is bind-mounted onto `/var/cache/apt`
* `/home/amnesia/` contains symlinks to every file in `$MEDIA/dotfiles`

## Activating and deactivating Persistent Storage Features

XXX: describe what activating and deactivating actually means. especially,
clarify the non trivial bits:

### Initial activation

We want to support this user story:
 1. User opens an application and configures it
 2. Then, the user decides they want this configuration to persist

To do this, we need to copy the volatile data to the persistent storage when
activating the corresponding feature.

### Conflicting apps

We have a pre-defined list of conflicting applications and processes that would
interfere with activating/deactivating a feature. For example, if the user is
activating Thunderbid feature, and they are running Thunderbird already, we
can't just `mount` the directory at the proper place: Thunderbird would never
notice, and this would lead to all sort of incoherent states.

### Hooks

[Hooks](link to relevant directory) are executed on activation / deactivation . They are important to have
because they enable proper integration. For example, making persistent
printers available cannot be done only via `mount`ing: you also need to restart
`cups.


## User interface

We provide a unified interface for creating, configuring and deleting a Persistent Storage.
Unlocking is, instead, performed by Welcome Scren.

### Create persistent storage


#### Design

Running the Persistent Storage UI:

Brings the user to the configuration screen if they have an unlocked Persistent Storage.

Else, we create:

 * on the USB stick Tails is running from
 * ask the user an encryption passphrase (welcome bonus: pointing to
   the relevant documentation about choosing a *strong* passphrase)
 * create a LUKS-encrypted partition on the Tails USB stick
   - uses all the free space
   - labeled `TailsData`
   - create an ext4 filesystem in the encrypted container
   - set appropriate ownership XXX: link to code
 * switch to the Configuration screen

### Configure persistent storage features (ie: which bits are persistent)

This is automatically run right after the Persistent Storage bootstrap
step. The user is enabled to change the configuration later.
Changes to the Persistent Storage settings are taken into account immediately.

#### Design

When the user sees this UI, it means either:
 - they have unlocked the Persistent Storage at the Welcome Scren
 - or, they just created it

By default, the "Create" UI will activate those features:
 - Persistent directory
 - Additional Software

A few _Features_ are made available. See section "Application-specific configuration"
XXX: proper link

### Unlock the Persistent Storage at boot time

The Welcome Screen allows the user to unlock their persistent storage.

The decision of doing this so late in the boot process is a conscious one: the Welcome Screen is a GTK
application that can easily support accessibility, an easy to use interface, keyboard layouts and input
systems.

We also don't support activating persistent storage after logging into the
GNOME Session.  It's full of corner cases, and we consider that doing this in a
way that gives a consistent interface to the user is very expensive and not
worth it.

Unlocking the Persistent Storage is optional: a user can start Tails without activating persistence. If they
do so, they won't be able to unlock it later without rebooting.

#### Design

 0. `tails-greeter` asks `tps` whether there's an available Persistent Storage
 0. The user chooses to unlock the Persistent Storage in the Welcome
    Screen, aka. `tails-greeter`.
 0. `tails-greeter` asks the user to enter the
    passphrase, and asks `tps` to unlock and activate.
    `tails-greeter` deals with error catching, retrying, etc. as appropriate.
     - Activation is all or nothing: all enabled
       Persistent Storage Features will be activated


#### Implementation details


<a id="additional-software-packages"></a>

Additional software packages
----------------------------

The `tails-additional-software` script installs a list of
additional software packages stored in the Persistent Storage.
For details see [[additional_software_packages]].

<a id="security"></a>

Security
--------

### storage access

XXX: check if that is true. Both the username and the ACL part

The root directory of the Persistent Storage is created
by the persistence configuration assistant, owned by `root:root`, with
permissions 0770. It is group-writable so that we can grant write access
to other users with ACLs.

Additionally, ACLs grant, on this directory:

* full (`rwx`) access to the `tails-persistence-setup` user, so that it can edit the
  persistence configuration;
* search (`x`) access to the `amnesia` user, so that it can follow the symlinks
  generated by the dotfiles feature.

### how can an unprivileged user have a privileged UI

XXX: update all that, also taking bits from the intro written on top of this document

 - A daemon, `tps` is run as root
 - How do we give the UI full access to the TPS D-Bus service
 - How do we prevent any other code running as `amnesia` to do the same
 - There is a tps CLI. What access do they provide? Who can use that to do what? How is that secure?

XXX: check this!
It creates and updates a configuration file called `persistence.conf`, that is
owned by `tails-persistence-setup:tails-persistence-setup`, with permissions
0600 and no ACLs. It refuses to read configuration files with different
permissions.

`live-persist` checks these permissions on the root directory of the
Persistent Storage, on `persistence.conf` and on
`live-additional-software.conf`. Then, `live-persist` disables every
such file, and refuses to set up any feature of the Persistent Storage, if the
Persistent Storage has wrong permissions. It also disables every such
file that has wrong permissions itself.

